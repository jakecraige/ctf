#!/usr/bin/env python3
import secrets
import hashlib
import itertools
from pwn import *
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

"""
perl -e 'print "A"x11 . "\n" . "B"x11 . "\n" . "C"x11 . "\n" . "D"x11 . "\n" . "E"x11' | nc regdb.hackthe.vote 50007

Flag is encrypted. Our job is to be able to recover key and decrypt plaintext.

- Random key for every session
- User controlled passsword for PBKDF2HMAC. Some sort of partial reuse?
 - req: unique, >10 and <100, printable chars
- It encrypts plaintexts randomly (may not even have flag in output)
- https://mathiasbynens.be/notes/pbkdf2-hmac
  > HMAC has an interesting property: if a supplied key is longer than the block
  > size of the hash function thatâ€™s being used, it uses the hash of the key
  > rather than the key itself.
- We know 4 of the plaintexts, this also will be useful for XOR-ing to get the
  keystream.

Possible exploit:
    1. Provide colliding nonces as input, 5 would be ideal but we may not be
       able to have that many colliding inputs. Even with just 2 we should
       be able to.
    2. For each ciphertext:
       - XOR known plaintexts to get a potential key stream
       - XOR key stream against other ciphertexts to see if we get ASCII
         aka correctness check.
       - One of them may be the flag (may have to try again because of rand)
"""

def test_pbkdf2hmac_collision(value):
    """
    This shows the colliding behavior of pbkdf2 when the password is longer than
    the hash block size and it hashes it to bring it down, thus colliding the
    mac as well. https://www.mscs.dal.ca/~selinger/md5collision/

    Example input: (value must be larger than 64, md5 block size)
        test_pbkdf2hmac_collision(b"A"*65)
    """
    salt = b"AAAAAAAAAAAAAAAA" # doesn't matter
    value_md5 = hashlib.md5(value).digest()
    mac1 = PBKDF2HMAC(algorithm=hashes.MD5(), length=32, salt=salt, iterations=100000, backend=default_backend()).derive(value),
    mac2 = PBKDF2HMAC(algorithm=hashes.MD5(), length=32, salt=salt, iterations=100000, backend=default_backend()).derive(value_md5),

    print("1: pbkdf: " + mac1[0].hex())
    print("2: pbkdf: " + mac2[0].hex())

KNOWN_PLAINTEXTS = [
    b"Sandra R. Jackson;reg2;1728 Goldie Lane",
    b"Leo N. Shatley;reg1;2251 Sunburst Drive",
    b"Faye S. Ramsey;reg2;3186 Froebre Street",
    b"Charles C. Felix;reg3;2726 Locust Court",
]

def attempt_solve():
    """
    Attempts to solve for the plaintexts and retuns them.
    """
    if args.REMOTE:
        io = remote("regdb.hackthe.vote", 50007)
    else:
        #  io = process(["./server-simple-deterministic.py", "stdin"])
        #  io = process(["./server-wo-nonce-constraint.py", "stdin"])
        io = process(["./server.py", "stdin"])
    io.recv() # hello msg

    # First two inputs derived with the find_input() function. The second value
    # is the MD5 of the first. The last 3 can be anything, they aren't used in
    # this solution.
    nonces = [
        "000000000000000000000000000000000000000000000000000000000000000000007],B",
        "jc$jG-j\".u~goowc",
        b"A"*16, # w/e
        b"B"*16, # w/e
        b"C"*16  # w/e
    ]

    cts = []
    for nonce in nonces:
        io.sendline(nonce)
        ct = unhex(io.recv()[:-1])[:-16] # clip trailing IV
        cts.append(ct)

    # Brute force to find the keystream. We assume we found it when we are able
    # to decrypt a CT with it and get all printable characters.
    found = False
    keystream = None
    for ct in cts:
        for known_pt in KNOWN_PLAINTEXTS:
            keystream = xor(ct, known_pt)
            for test_ct in cts:
                pt = xor(keystream, test_ct)
                if all([c in string.printable.encode() for c in pt]):
                    found = True
                    break
            if found:
                break
        if found:
            break

    pts = []
    for ct in cts:
        pt = xor(keystream, ct)
        pts.append(pt[:len(ct)])

    return pts

def exploit():
    while True:
        pts = attempt_solve()
        flag = next(iter([pt for pt in pts if b"flag" in pt]), None)
        if flag:
            log.success("Flag: " + str(flag))
            break


def find_input():
    """
    Find ASCII string >64 && <100 chars where the MD5 hash is ASCII
    representable.
    """
    found = False
    # string.printable with chars that would be stripped removed because the
    # implementation calls .strip on the input. We could allow these in the
    # middle but it's simpler not to at all.
    charset = b'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

    # We generate one of length 72, but anything in the valid range might work.
    # I just sort of randomly chose this one and it worked
    for char_tup in itertools.product(charset, repeat=72):
        possible = "".join([chr(char) for char in char_tup])
        digest = hashlib.md5(possible.encode()).digest()

        if all([c in charset for c in digest]):
            return (digest, possible)

#  test_pbkdf2hmac_collision(b"A"*65)
exploit()
