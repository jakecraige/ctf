from pwn import *
from Crypto.Util.strxor import strxor

def exploit():
    flag = b""

    # Decrypt block 1
    io = remote("chal.duc.tf", 30201)
    io.recvuntil("read: ")
    flag_enc = unhex(io.readline()[:-1])
    io.recvuntil("Enter plaintext to encrypt (hex): ")
    io.sendline(flag_enc[:16].hex())
    ct = unhex(io.readline()[:-1])
    io.recvuntil("Enter ciphertext to decrypt (hex): ")
    io.sendline(flag_enc[:16].hex())
    pt = unhex(io.readline()[:-1])
    log.success("Decrypted first block: " + pt.decode())
    flag += pt
    io.close()

    num_blocks = int(len(flag_enc) / 16)-1 # sub 1 because we already know block 1
    for i in range(0, num_blocks):
        io = remote("chal.duc.tf", 30201)
        io.recvuntil("read: ")
        flag_enc = unhex(io.readline()[:-1])

        # Leak the IV.
        # - We pass in a 16-byte block of padding (so 16 16s)
        # - It pads it once more block
        # - The last block is: IV XOR E(out_input) XOR E(auto-padding)
        # - The padding cancels out and we just get the IV
        io.recvuntil("Enter plaintext to encrypt (hex): ")
        pad_block = b"\x10"*16
        io.sendline(pad_block.hex())
        ct = unhex(io.readline()[:-1])
        iv = ct[16:]
        log.success("Leaked iv " + iv.hex())

        # Leverage leaked IV to decrypt block
        # - Single block decryption is D(block XOR IV)
        # - Notice that ct_0 XOR ct_1 = E(pt_1)
        # - We can XOR in the IV to get E(pt_1) XOR IV
        # - Now when we decrypt we get pt_1
        io.recvuntil("Enter ciphertext to decrypt (hex): ")
        off = 16*i # offset from start of enc
        ct_sub1 = flag_enc[off:off+16]
        ct_this = flag_enc[off+16:off+32]
        in_pt = strxor(strxor(ct_sub1, ct_this), iv)
        io.sendline(in_pt.hex())
        pt = unhex(io.readline()[:-1])
        log.success("Decrypted block: " + pt.decode())
        flag += pt
        io.close()

    log.success("Flag: " + flag.decode())

exploit()
