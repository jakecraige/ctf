from pwn import *
from os import urandom
from Crypto.Util.strxor import strxor

sample = b'cashcashcashcash'
solution_message = b'flagflagflagflag'

def exploit():
    flag = b""

    io = remote("chal.duc.tf", 30202)
    io.recvuntil(" signature ")
    sig = unhex(io.readline()[:-2])
    mac, iv = sig[:-16], sig[-16:]

    # The original mac/iv is:
    #   E(sample XOR iv) || iv
    #
    # By mutating the IV we can cancel out the original message and include our own.
    #   set iv' = iv XOR sample XOR solution
    #   set sig = mac || iv'
    #
    # When submitted here is how it verifies:
    #   computed = sign(solution, iv')
    #   computed = E(solution XOR iv') || iv
    #   computed = E(solution XOR (iv XOR sample XOR solution)) || iv'
    #   computed = E(iv XOR sample) || iv'
    #   computed == sig (it does)
    #
    # The trick is that the solution cancels out of the input to encrypt so the
    # original mac is still valid.
    forged_iv = strxor(strxor(iv, sample), solution_message)

    io.recvuntil(" your message: ")
    io.sendline(solution_message)
    io.recvuntil(" the signature (in hex): ")
    io.sendline((mac+forged_iv).hex())
    io.readline() # Valid/invalid message
    io.success("Flag: " + io.readline()[:-1].decode())

exploit()

