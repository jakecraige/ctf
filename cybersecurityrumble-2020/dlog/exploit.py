#!/usr/bin/env python3
from pwn import *
import ecdsa

"""
This challenge accepts an (x, y) coordinate which is used as the generator and
then a secret scalar is multiplied by it and the resulting group element is
returned. A new secret is generated every time.

It then asks for the secret and if correct, prints the flag.

- Secret is newly random          (multiple queries can't be used for secret)
- Secret is 32 /dev/urandom bytes (not brute forcable)
- Curve is secp256k1              (known secure curve)
- Point is not checked to be on the curve (!)
    - Seems like there ought to be some way to choose G maliciously
"""

if args.REMOTE:
    io = remote("chal.cybersecurityrumble.de", 31782)
else:
    io = process(["python3", "./main.py"])
#  context.log_level = "DEBUG"

# TODO: Somehow choose these usefully
#  x = 1
#  y = 2
# max 5 points
#  x, y = 82794344854243450371984501721340198645022926339504713863786955730156937886079, 33552521881581467670836617859178523407344471948513881718969729275859461829010

x, y = 1, 1

io.recvuntil("x: ")
io.sendline(str(x))
io.recvuntil("y: ")
io.sendline(str(y))
io.recvuntil("point: \n")
(x_str, y_str) = io.recvuntil(")")[6:-1].split(b",")
log.info(b"X: " + x_str)
log.info(b"Y: " + y_str)
#  (x, y) = int(x_str), int(y_str)
io.clean()

# TODO: Actually find secret
secret = 1337
io.sendline(str(secret))

log.info(io.recv().decode())
#  io.interactive()


